<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[韦老六子网划分]]></title>
    <url>%2F2018%2F12%2F17%2F%E9%9F%A6%E8%80%81%E5%85%AD%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021128 64 32 16 8 4 2 110000000 = 12811000000 = 19211100000 = 22411110000 = 24011111000 = 24811111100 = 25211111110 = 25411111111 = 255A类：0.0.0.0 ~ 127.255.255.255B类：128.0.0.0 ~ 191.255.255.255C类：192.0.0.0 ~ 223.255.255.255D类：（组播）224.0.0.0 ~ 239.255.255.255E类：（保留、科研）240.0.0.0 ~ 255.255.255.255 子网划分192.168.1.0 255.255.255.0要求划分 2 个子网 步骤： 判断给出的 IP 地址的类别（A、B、C），确定自然分类的掩码 A-&gt;/8，B-&gt;/16，C-&gt;/24 以上要求为 C 类地址，掩码长度 255.255.255.0（/24） 根据要求 确认 具体要划分几个子网后，判断具体需要向主机位借几位 以上要求划分 2 个子网，公式：2 的几次方（n）小于等于 2 2^n $\geq 2$ ====&gt; n = 1 则需要向主机位 借 1 位 即可满足两个子网 写出子网的子网掩码长度255.255.255.00000000 ==借 1 位== =》255.255.255.128（/25） 使用公式：256 - 子网掩码最后一段有效数字，得出每个网段的网段间距256 - 128 = 128（每个网段的网段间距） 使用每个网段的网段间距 相加 相减 得出每个网段的网络地址 1234网络地址：192.168.1.0192.168.1.128192.168.1.256 使用每个网段的网络地址 ==最后一段有效数字减一==，得出上一网段的广播地址 1234网络地址 广播地址 可用主机地址192.168.1.0 ---》192.168.1.127 ---》192.168.1.1 ~ 192.168.1.126192.168.1.128 ---》192.168.1.255 ---》192.168.1.129 ~ 192.168.1.254192.168.1.256 两个子网如下：192.168.1.0 255.255.255.128192.168.1.128 255.255.255.128 例 1：给出一个子网 判断 IP 地址的数量 和 可用 IP 地址的数量192.168.1.128 255.255.255.128 步骤： 将子网掩码的位数计算出来255.255.255.255.128 /25` 通过子网掩码的位数，去判断网络地址和主机地址的长度 12主机位的长度（Y）= 32 - 25 = 7则主机位的长度为 7 bit IP 地址的数量：2 的 Y 次方2^Y^ = 2^7^ = 128 可用 IP 地址的数量 = IP 地址的数量 - 2（网络地址和广播地址）128 - 2 = 126 例 2：192.168.1.0/24需求：第一个子网 30 台主机第二个子网 20 台主机第三个子网 10 台主机 步骤： 根据需求分析，第一个子网 要求可用地址为 30 个，则此网络共有 IP 为 30 + 2 = 32 因为划分子网中 ==IP 地址的数量== 由 ==主机位的长度 Y== 判断则 2^Y^ $\geq 32$ ==&gt; 主机位的长度Y = 5 根据计算出来的主机位长度，确定网络位的长度位：32 - 5 = 27则子网掩码长度为 27 的时候可以满足第一个子网的要求255.255.255.11100000—–》255.255.255.224 使用公式 256 - 子网掩码最后一段中有效数字，得到每个子网的网段间距256 - 224 = 32 使用 32 相加、相减得到每个子网的网络地址 12345678910网络地址：192.168.1.0192.168.1.32192.168.1.64192.168.1.96192.168.1.128192.168.1.160192.168.1.192192.168.1.224192.168.1.256 使用每个子网的网络地址最后一段的有效数字减一，得出上一段子网的广播地址 12345678910网络地址： 广播地址192.168.1.0 ---------192.168.1.31192.168.1.32 ---------192.168.1.63192.168.1.64 ---------192.168.1.95192.168.1.96 ---------192.168.1.127192.168.1.128 ---------192.168.1.159192.168.1.160 ---------192.168.1.191192.168.1.192 ---------192.168.1.223192.168.1.224 ---------192.168.1.255192.168.1.256 满足 30 个可用地址192.168.1.0 ———192.168.1.31 可用地址：192.168.1.1 ~ 192.168.1.30满足 20 个可用地址192.168.1.32 ———192.168.1.63 可用地址：192.168.1.33 ~ 192.168.1.62 10 个可用地址用 30 还是会有浪费，继续子网划分192.168.1.64 255.255.255.22410 + 2 = 122^Y^ $\geq 12$ ——–》Y = 4网络地址的长度：32 - 4 = 28255.255.255.240网段间距：256 - 240 = 16123456789网络地址：192.168.1.64192.168.1.80192.168.1.96广播地址192.168.1.79192.168.1.95可用地址：192.168.1.65 ~ 192.168.1.78 192.168.1.81 ~ 192.168.1.94 满足 10 个可用地址192.168.1.65 ~ 192.168.1.78]]></content>
  </entry>
  <entry>
    <title><![CDATA[WSL(Windows Subsystem for Linux)]]></title>
    <url>%2F2018%2F11%2F18%2FWSL-Windows-Subsystem-for-Linux%2F</url>
    <content type="text"><![CDATA[有关WSL的介绍这里就不做解释了。另外，本文仅适用于win10 build 16215以及之后的版本，之前的版本可参考官方链接。 （可使用“winver”命令查看windows版本号） 安装 控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选 适用于Linux的Windows子系统 重启电脑 打开应用商城搜索“WSL”，可根据自己需求选择安装一个或多个Linux系统： 安装完成后可在开始菜单里找到快捷方式并启动，第一次运行需要等待安装并设置用户名、密码。除此以外，在cmd中使用以下几个命令都可以运行WSL：wsl 或者 bashwsl [command]或者bash -c [command]Linux系统名称（如：ubuntu），这跟上面在开始菜单里启动是一样的其中，前两种方式会运行默认的linux系统，当你安装多个linux系统之后可以使用wslconfig来指定使用wslconfig命令进行管理 设置默认运行的linux系统wslconfig /setdefault &lt;DistributionName&gt;正如上面所说，如果执行wslconfig /setdefault ubuntu，那么执行bash命令则会运行ubuntu 卸载linux系统wslconfig /unregister &lt;DistributionName&gt;当系统出现问题，我们可以卸载后重新安装。如：wslconfig /unregeister ubuntu 查看已安装的linux系统wslconfig /list 使用wslconfig命令进行管理当我们运行WSL时，它会用第一次运行时输入的用户名登陆，如果想改为其他用户，可以（以ubuntu为例）： ubuntu config --default-user root 这样，以后再运行ubuntu它就会默认以root登陆。此外还可以“ubuntu /?”查看其更多使用方法。 WSL文件系统与本地文件系统互相访问 WSL中访问本地文件在“/mnt”目录下有“c”、“d”、“e”等文件夹，分别表示本地的C盘、D盘、E盘，直接cd到相应路径下即可。 本地访问WSL的根目录微软强烈不建议在外部对WSL文件系统进行更改，所以未公开WSL所在的根目录。毕竟有时候我们需要直接读取里面的很多文件（比如说在某个IDE里面设置include path为WSL的/usr/include），如果每次都在WSL里cp命令将其拷贝到本地又太麻烦。下面是其根目录（以ubuntu为例，版本不同可能会有略微差别）：(C:\Users\XXXX\AppData\Local\Packages\CanonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc\LocalState\rootfs) 到此为止你就可以在 Windows 使用 Linux 啦，也不用装双系统，麻烦的双系统切换，也不用担心虚拟机的性能损耗好了接下来就和正常玩shell一样了，尽情的享受运行WSL吧（对了，我图里用的是 cmder）]]></content>
  </entry>
  <entry>
    <title><![CDATA[记百大东合水卡破解]]></title>
    <url>%2F2018%2F10%2F02%2F%E8%AE%B0%E7%99%BE%E5%A4%A7%E4%B8%9C%E5%90%88%E6%B0%B4%E5%8D%A1%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[步骤：1. 通过多次刷取，使卡内金额发生改变，从而对比发现数据所在扇区2. 现在把数据块拿出来单独分析 3.计算我们以第一条数据为例 金额位（i1、i2） 金额：68.35将其转换为十六进制就是 1AB3 接着看一下数据（惊喜有没有） 倒过来就是 B31A 与 i1、i2 相同这样我们的金额位就简单得到了，下面折腾校验位 校验位（checksum） 按位取反（事实证明这次破解中没有用到） B31A 二进制=&gt;1011001100011010 取反=&gt;0100110011100101 =&gt;4CE5 （ps:刚开始我的思路就是以上的按照金额来按位取反，实验证明没P用，过于沙雕，不过鉴于有的卡还是会用到这样的方法，写了就不删了吧） 下面换个思路我们将金额位和校验位分别转换成十进制金额位：B3 转换为十进制：1791A 转换为十进制：26 校验位：FC 转换为十进制：252 再将两个金额位的十进制数求和179 + 26 = 205 这里先说明一下思路：金额前后两位分别转十进制， 求和，与校验位十进制 差或者和为一个定值，基本上大多数水卡都是这个校验算法。我这里试验过了是以差作为一个定值，所以我就直接计算了：252 - 205 = 47再把结果转成十六进制：2F，这就是我这张卡的定值了。 现在我们就可以算校验位了,将金额位的和再与定值相加：B3 + 1A = CDCD + 2F = FC 以上 FC 即是计算出来的校验位，我们来和数据中的对比一下 方法到此结束，我们来看一看成果：(注：本篇文章属于兴趣学习)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F10%2F02%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
